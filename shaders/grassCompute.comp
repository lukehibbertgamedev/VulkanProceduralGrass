#version 450

// A shader copy of the BladeInstanceData structure defined in GrassBlade.h.
// This contains all instances of all grass blades, indexed by gl_InstanceIndex.
struct BladeInstanceData {
    
    vec4 p0_and_width;
    vec4 p1_and_height;
    vec4 p2_and_direction;
    vec4 upVec_and_stiffness;             
};

// Read from the previous frame, and write to the current frame. 
// This will wrap so the updated current frame will become the readonly previous frame.
layout(std140, binding = 1) buffer BladeInstanceDataBufferLastFrame {
    BladeInstanceData bladesIn[]; 
};

// Write to the current frame, wrapped to the next frame to allow new data to be read.
layout(std140, binding = 2) buffer BladeInstanceDataBufferCurrentFrame {
    BladeInstanceData bladesOut[]; 
};

layout(push_constant) uniform PushConstants {
    float elapsed;
} pushConstants;

void keepPersistentLength(in vec3 v0, inout vec3 v1, inout vec3 v2, in float height) {
    vec3 v01 = v1 - v0;
    vec3 v12 = v2 - v1;
    float lv01 = length(v01);
    float lv12 = length(v12);
    float L1 = lv01 + lv12;
    float L0 = length(v2 - v0);

    //http://steve.hollasch.net/cgindex/curves/cbezarclen.html
    float L = (2.0 * L0 + L1) / 3.0;

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 = v0 + v01;
    v2 = v1 + v12;
}

vec3 calculateDirectionVector(in vec3 up, in float directionAngle) {
    float sinDir = sin(directionAngle);
    float cosDir = cos(directionAngle);
    vec3 temp = normalize(vec3(sinDir, sinDir + cosDir, cosDir));
    return normalize(cross(up, temp));
}

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

void main() 
{
    uint threadID_x = gl_GlobalInvocationID.x; // Thread ID within the grid's x-space.

    BladeInstanceData bladeIn = bladesIn[threadID_x]; 

    float height = bladeIn.p1_and_height.w;
    vec3 directionVector = vec3(cos(radians(bladeIn.p2_and_direction.w)), 0.0, sin(radians(bladeIn.p2_and_direction.w))); // Assumes Z is up.
    //vec3 directionVector = calculateDirectionVector(bladeIn.upVec_and_stiffness.xyz, radians(bladeIn.p2_and_direction.w)); // Assumes Z is up.

    float swaySpeed = 2.0;
    float swayAmplitude = 0.6;
    float swayValue = (sin(pushConstants.elapsed * swaySpeed) * 0.5 + 0.5) * swayAmplitude;

    //vec3 swayVector = directionVector * swayValue * height;
    //vec3 modifiedP2 = bladeIn.p2_and_direction.xyz + swayVector;   
    //vec3 p0 = bladeIn.p0_and_width.xyz;
    //vec3 p1 = bladeIn.p1_and_height.xyz;
    //vec3 p2 = modifiedP2;
    //keepPersistentLength(p0, p1, p2, height);
    bladesOut[threadID_x] = bladeIn;
    //bladesOut[threadID_x].p2_and_direction.xyz = p2;

    float swayX = (2.0 * sin(1.0 * (bladeIn.p0_and_width.x + bladeIn.p0_and_width.y + bladeIn.p0_and_width.z + pushConstants.elapsed))) + 1.0;
    float swayY = (1.0 * sin(2.0 * (bladeIn.p0_and_width.x + bladeIn.p0_and_width.y + bladeIn.p0_and_width.z + pushConstants.elapsed))) + 0.5;
    float swayZ = 0.0;
    
    vec3 swayVec = directionVector * vec3(swayX, swayY, swayZ) * height;
    vec3 modifiedP2 = bladeIn.p2_and_direction.xyz + swayVec * (height - 0.06);
    keepPersistentLength(bladeIn.p0_and_width.xyz, bladeIn.p1_and_height.xyz, modifiedP2, height);
    bladesOut[threadID_x].p2_and_direction.xyz = modifiedP2;  
}