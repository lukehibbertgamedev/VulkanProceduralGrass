#version 450

// A shader copy of the BladeInstanceData structure defined in GrassBlade.h.
// This contains all instances of all grass blades, indexed by gl_InstanceIndex.
struct BladeInstanceData {
    
    vec4 p0_and_width;
    vec4 p1_and_height;
    vec4 p2_and_direction;
    vec4 upVec_and_stiffness;             
};

// Read from the previous frame, and write to the current frame. 
// This will wrap so the updated current frame will become the readonly previous frame.
layout(std140, binding = 1) buffer BladeInstanceDataBufferLastFrame {
    BladeInstanceData bladesIn[]; 
};

// Write to the current frame, wrapped to the next frame to allow new data to be read.
layout(std140, binding = 2) buffer BladeInstanceDataBufferCurrentFrame {
    BladeInstanceData bladesOut[]; 
};

layout(push_constant) uniform PushConstants {
    float elapsed;
} pushConstants;

void keepPersistentLength(in vec3 v0, inout vec3 v1, inout vec3 v2, in float height) {
    vec3 v01 = v1 - v0;
    vec3 v12 = v2 - v1;
    float lv01 = length(v01);
    float lv12 = length(v12);
    float L1 = lv01 + lv12;
    float L0 = length(v2 - v0);

    //http://steve.hollasch.net/cgindex/curves/cbezarclen.html
    float L = (2.0 * L0 + L1) / 3.0;

    float ldiff = height / L;
    v01 = v01 * ldiff;
    v12 = v12 * ldiff;
    v1 = v0 + v01;
    v2 = v1 + v12;
}

//	Classic Perlin 2D Noise 
//	by Stefan Gustavson (https://github.com/stegu/webgl-noise)
//
vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
float cnoise(vec2 P){
  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation
  vec4 ix = Pi.xzxz;
  vec4 iy = Pi.yyww;
  vec4 fx = Pf.xzxz;
  vec4 fy = Pf.yyww;
  vec4 i = permute(permute(ix) + iy);
  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...
  vec4 gy = abs(gx) - 0.5;
  vec4 tx = floor(gx + 0.5);
  gx = gx - tx;
  vec2 g00 = vec2(gx.x,gy.x);
  vec2 g10 = vec2(gx.y,gy.y);
  vec2 g01 = vec2(gx.z,gy.z);
  vec2 g11 = vec2(gx.w,gy.w);
  vec4 norm = 1.79284291400159 - 0.85373472095314 * 
    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
  g00 *= norm.x;
  g01 *= norm.y;
  g10 *= norm.z;
  g11 *= norm.w;
  float n00 = dot(g00, vec2(fx.x, fy.x));
  float n10 = dot(g10, vec2(fx.y, fy.y));
  float n01 = dot(g01, vec2(fx.z, fy.z));
  float n11 = dot(g11, vec2(fx.w, fy.w));
  vec2 fade_xy = fade(Pf.xy);
  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}

vec3 GetWindOffset(vec2 pos, vec3 windDirection, float time) {
    float posOnSin = cos(windDirection.x) * pos.x - sin(windDirection.y) * pos.y;
    float t = time + posOnSin + 4.0 * cnoise(0.1 * pos);
    float windx = 2.0 * sin(0.5 * t);
    float windy = 1.0 * sin(1.0 * t);
    vec3 windVec = vec3(windx, windy, 0.0);
    return windVec * 0.25;
}

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

void main() 
{
    uint threadID_x = gl_GlobalInvocationID.x; // Thread ID within the grid's x-space.

    BladeInstanceData bladeIn = bladesIn[threadID_x]; 

    float height = bladeIn.p1_and_height.w;
    vec3 directionVector = vec3(cos(radians(bladeIn.p2_and_direction.w)), 0.0, sin(radians(bladeIn.p2_and_direction.w))); // Assumes Z is up.
    //vec3 directionVector = calculateDirectionVector(bladeIn.upVec_and_stiffness.xyz, radians(bladeIn.p2_and_direction.w)); // Assumes Z is up.

    float swaySpeed = 2.0;
    float swayAmplitude = 0.6;
    float swayValue = (sin(pushConstants.elapsed * swaySpeed) * 0.5 + 0.5) * swayAmplitude;

    //vec3 swayVector = directionVector * swayValue * height;
    //vec3 modifiedP2 = bladeIn.p2_and_direction.xyz + swayVector;   
    //vec3 p0 = bladeIn.p0_and_width.xyz;
    //vec3 p1 = bladeIn.p1_and_height.xyz;
    //vec3 p2 = modifiedP2;
    //keepPersistentLength(p0, p1, p2, height);
    bladesOut[threadID_x] = bladeIn;
    //bladesOut[threadID_x].p2_and_direction.xyz = p2;

    //float swayX = (2.0 * sin(1.0 * (bladeIn.p0_and_width.x + bladeIn.p0_and_width.y + bladeIn.p0_and_width.z + pushConstants.elapsed))) + 1.0;
    //float swayY = (1.0 * sin(2.0 * (bladeIn.p0_and_width.x + bladeIn.p0_and_width.y + bladeIn.p0_and_width.z + pushConstants.elapsed))) + 0.5;
    //float swayZ = 0.0;
    
    //vec3 swayVec = directionVector * vec3(swayX, swayY, swayZ) * height;
    //vec3 modifiedP2 = bladeIn.p2_and_direction.xyz + swayVec * (height - 0.06);
    //keepPersistentLength(bladeIn.p0_and_width.xyz, bladeIn.p1_and_height.xyz, modifiedP2, height);
    //bladesOut[threadID_x].p2_and_direction.xyz = modifiedP2;  

    //vec3 modifiedP2 = bladeIn.p1_and_height.xyz + directionVector * height * 0.3;
    vec3 modifiedP2 = bladeIn.p2_and_direction.xyz;
    modifiedP2 += GetWindOffset(bladeIn.p2_and_direction.xy, directionVector, pushConstants.elapsed);
    keepPersistentLength(bladeIn.p0_and_width.xyz, bladeIn.p1_and_height.xyz, bladesOut[threadID_x].p2_and_direction.xyz, height);
    bladesOut[threadID_x] = bladeIn;
    bladesOut[threadID_x].p2_and_direction.xyz = modifiedP2;  


}